name: .NET

on:
  push:
    branches: ['AlexTemp']
  pull_request:
    branches: ['AlexTemp']

jobs:
  deployment:
    environment: 'Production'
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4
      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: 8.0.x
      - name: Restore dependencies
        run: dotnet restore
      - name: Build
        run: dotnet build --no-restore
      - name: Publish
        run: dotnet publish CookWithWhat.API/CookWithWhat.API.csproj --configuration Release --runtime linux-x64 --self-contained --output ./out

      # Configure AWS credentials
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: eu-west-2

      # Check if EC2 instance exists
      - name: Check if EC2 instance exists
        id: check_ec2
        run: |
          INSTANCE_ID=$(aws ec2 describe-instances --filters "Name=tag:Name,Values=CWW" "Name=instance-state-name,Values=running" --query "Reservations[].Instances[?State.Name=='running'].InstanceId" --output text)
          echo "instance_id=$INSTANCE_ID" >> $GITHUB_OUTPUT

      # Create EC2 instance if not exists
      - name: Create EC2 instance if not exists
        if: steps.check_ec2.outputs.instance_id == ''
        id: create_ec2
        run: |
          INSTANCE_ID=$(aws ec2 run-instances \
              --image-id ami-026b2ae0ba2773e0a \
              --instance-type t2.micro \
              --key-name CWW \
              --tag-specifications 'ResourceType=instance,Tags=[{Key=Name,Value=CWW}]' \
              --query 'Instances[0].InstanceId' \
              --output text)
          echo "Created new EC2 instance with ID: $INSTANCE_ID"
          echo "instance_id=$INSTANCE_ID" >> $GITHUB_OUTPUT

  

      # Check if key pair exists
      - name: Check if key pair exists
        run: |
          KEY_PAIR=$(aws ec2 describe-key-pairs --key-names CWW --query 'KeyPairs[*].KeyName' --output text)
          if [ -z "$KEY_PAIR" ]; then
            echo "Error: CWW key pair does not exist in AWS. Please create it first."
            exit 1
          fi

      # Set instance ID
      - name: Set instance ID
        id: set_instance
        run: |
          INSTANCE_ID=${{ steps.check_ec2.outputs.instance_id || steps.create_ec2.outputs.instance_id }}
          echo "instance_id=$INSTANCE_ID" >> $GITHUB_OUTPUT
          
      # Wait for instance to be running and ready
      - name: Wait for instance to be running and ready
        run: |
          messages=(
            "Calibrating the warp drive..."
            "Engaging hyperdrive sequence..."
            "Uploading the Matrix..."
            "Summoning the Elder Gods of Code..."
            "Generating infinite improbability..."
            "Aligning the Stargate coordinates..."
            "Deploying minions to the cloud..."
            "Energizing photon torpedoes..."
            "Spinning up the TARDIS..."
            "Compiling quantum algorithms..."
            "Rendering the holodeck simulation..."
            "Initializing lightsaber protocols..."
            "Powering up the Infinity Gauntlet..."
            "Syncing with the Batcomputer..."
            "Brewing a cup of Java..."
            "Encrypting with the Enigma machine..."
            "Building the Death Star..."
            "Activating stealth mode..."
            "Merging with the Borg Collective..."
            "Generating warp field..."
            "Configuring the neural network..."
            "Charging the proton packs..."
            "Hacking the Gibson..."
            "Inserting the Mario cartridge..."
            "Connecting to the Holonet..."
            "Aligning magnetic fields..."
            "Engaging cloak of invisibility..."
            "Calculating Pi to infinity..."
            "Resurrecting the Necromancer's code..."
          )

          message_index=0
          echo "Waiting for instance to be in running state..."
          while true; do
            STATE=$(aws ec2 describe-instances --instance-ids ${{ steps.set_instance.outputs.instance_id }} --query 'Reservations[].Instances[].State.Name' --output text)
            if [ "$STATE" = "running" ]; then
              echo "Instance is now running. Waiting for status checks..."
              break
            fi
            echo "${messages[message_index]}"
            message_index=$(( (message_index + 1) % ${#messages[@]} ))
            sleep 10
          done

          echo "Performing final checks..."
          while true; do
            STATUS=$(aws ec2 describe-instance-status --instance-ids ${{ steps.set_instance.outputs.instance_id }} --query 'InstanceStatuses[].InstanceStatus.Status' --output text)
            if [ "$STATUS" = "ok" ]; then
              echo "Instance status checks passed. Instance is ready."
              break
            fi
            echo "${messages[message_index]}"
            message_index=$(( (message_index + 1) % ${#messages[@]} ))
            sleep 10
          done
            
      # Get public IP address
      - name: Get public IP address
        id: get_ip
        run: |
          PUBLIC_IP=$(aws ec2 describe-instances --instance-ids ${{ steps.set_instance.outputs.instance_id }} --query 'Reservations[].Instances[].PublicIpAddress' --output text)
          echo "public_ip=$PUBLIC_IP" >> $GITHUB_OUTPUT

      # Copy files to the EC2 instance.
      - name: Copy files to EC2
        uses: easingthemes/ssh-deploy@main
        with:
          SSH_PRIVATE_KEY: ${{ secrets.SSH_KEY }}
          REMOTE_HOST: ${{ steps.get_ip.outputs.public_ip }}
          REMOTE_USER: ec2-user
          SOURCE: "./out/"
          TARGET: "/home/ec2-user/app"
                 
      # Configure EC2 instance
      - name: Configure EC2 instance
        uses: appleboy/ssh-action@master
        with:
          host: ${{ steps.get_ip.outputs.public_ip }}
          username: ec2-user
          key: ${{ secrets.SSH_KEY }}
          script: |
            sudo yum install -y libicu
            sudo yum install nginx -y
            sudo tee /etc/nginx/nginx.conf > /dev/null <<EOT
            user nginx;
            worker_processes auto;

            error_log /var/log/nginx/error.log warn;
            pid /var/run/nginx.pid;

            events {
                worker_connections 1024;
            }

            http {
                include /etc/nginx/mime.types;
                default_type application/octet-stream;

                log_format main '\$remote_addr - \$remote_user [\$time_local] "\$request" '
                  '\$status \$body_bytes_sent "\$http_referer" '
                  '"\$http_user_agent" "\$http_x_forwarded_for"';

                access_log /var/log/nginx/access.log main;

                sendfile on;
                keepalive_timeout 65;

                include /etc/nginx/conf.d/*.conf;

                server {
                    listen 80;
                    server_name ${{ steps.get_ip.outputs.public_ip }}; # Using the EC2 instance's public IP

                    location / {
                        proxy_pass http://localhost:5000;
                        proxy_http_version 1.1;
                        proxy_set_header Upgrade \$http_upgrade;
                        proxy_set_header Connection keep-alive;
                        proxy_set_header Host \$host;
                        proxy_cache_bypass \$http_upgrade;
                        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
                        proxy_set_header X-Forwarded-Proto \$scheme;
                    }
                }
            }
            EOT
            sudo systemctl restart nginx;

            # Debug: Print current directory
            echo "Current directory: $(pwd)"
                  
            # Navigate to the app directory
            cd /home/ec2-user/app

            # Debug: Print contents of the directory
            echo "Contents of /home/ec2-user/app:"
            ls -la

            # Make the application executable
            chmod +x CookWithWhat.API

            # Debug: Check if the file is executable
            if [ -x CookWithWhat.API ]; then
              echo "CookWithWhat.API is executable"
            else
              echo "Error: CookWithWhat.API is not executable"
              exit 1
            fi

            # Run the application
            echo "Starting the application..."
            nohup ./CookWithWhat.API > /home/ec2-user/app.log 2>&1 &

            # Debug: Check if the application is running
            sleep 5  # Give it a moment to start
            if pgrep -f "./CookWithWhat.API" > /dev/null; then
              echo "Application is running."
              ps aux | grep CookWithWhat.API
            else
              echo "Error: Application failed to start. Here's the log:"
              cat /home/ec2-user/app.log
              exit 1
            fi

      # Output the public IP and test URL
      - name: Output Public IP and Test URL
        run: |
          echo "Your application is now running on http://${{ steps.get_ip.outputs.public_ip }}"
          echo "Test it on: http://${{ steps.get_ip.outputs.public_ip }}/Recipe/all"
        env:
          PUBLIC_IP: ${{ steps.get_ip.outputs.public_ip }}